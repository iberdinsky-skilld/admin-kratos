/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/health/alive": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check HTTP Server Status
         * @description This endpoint returns a HTTP 200 status code when Ory Kratos is accepting incoming
         *     HTTP requests. This status does currently not include checks whether the database connection is working.
         *
         *     If the service supports TLS Edge Termination, this endpoint does not require the
         *     `X-Forwarded-Proto` header to be set.
         *
         *     Be aware that if you are running multiple nodes of this service, the health status will never
         *     refer to the cluster state, only to a single instance.
         */
        get: operations["isAlive"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check HTTP Server and Database Status
         * @description This endpoint returns a HTTP 200 status code when Ory Kratos is up running and the environment dependencies (e.g.
         *     the database) are responsive as well.
         *
         *     If the service supports TLS Edge Termination, this endpoint does not require the
         *     `X-Forwarded-Proto` header to be set.
         *
         *     Be aware that if you are running multiple nodes of Ory Kratos, the health status will never
         *     refer to the cluster state, only to a single instance.
         */
        get: operations["isReady"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Identities
         * @description Lists all identities. Does not support search at the moment.
         *
         *     Learn how identities work in [Ory Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).
         */
        get: operations["listIdentities"];
        put?: never;
        /**
         * Create an Identity
         * @description This endpoint creates an identity. It is NOT possible to set an identity's credentials (password, ...)
         *     using this method! A way to achieve that will be introduced in the future.
         *
         *     Learn how identities work in [Ory Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).
         */
        post: operations["createIdentity"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identities/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Identity
         * @description Learn how identities work in [Ory Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).
         */
        get: operations["getIdentity"];
        /**
         * Update an Identity
         * @description This endpoint updates an identity. It is NOT possible to set an identity's credentials (password, ...)
         *     using this method! A way to achieve that will be introduced in the future.
         *
         *     The full identity payload (except credentials) is expected. This endpoint does not support patching.
         *
         *     Learn how identities work in [Ory Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).
         */
        put: operations["updateIdentity"];
        post?: never;
        /**
         * Delete an Identity
         * @description Calling this endpoint irrecoverably and permanently deletes the identity given its ID. This action can not be undone.
         *     This endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is
         *     assumed that is has been deleted already.
         *
         *     Learn how identities work in [Ory Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).
         */
        delete: operations["deleteIdentity"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics/prometheus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get snapshot metrics from the Kratos service. If you're using k8s, you can then add annotations to
         *     your deployment like so:
         * @description ```
         *     metadata:
         *     annotations:
         *     prometheus.io/port: "4434"
         *     prometheus.io/path: "/metrics/prometheus"
         *     ```
         */
        get: operations["prometheus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/recovery/link": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a Recovery Link
         * @description This endpoint creates a recovery link which should be given to the user in order for them to recover
         *     (or activate) their account.
         */
        post: operations["createRecoveryLink"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schemas/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a Traits Schema Definition */
        get: operations["getSchema"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/browser/flows/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Browser-Based Logout User Flow
         * @description This endpoint initializes a logout flow.
         *
         *     > This endpoint is NOT INTENDED for API clients and only works
         *     with browsers (Chrome, Firefox, ...).
         *
         *     On successful logout, the browser will be redirected (HTTP 302 Found) to the `return_to` parameter of the initial request
         *     or fall back to `urls.default_return_to`.
         *
         *     More information can be found at [Ory Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).
         */
        get: operations["initializeSelfServiceBrowserLogoutFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/browser/flows/registration/strategies/oidc/settings/connections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete the Browser-Based Settings Flow for the OpenID Connect Strategy
         * @description This endpoint completes a browser-based settings flow. This is usually achieved by POSTing data to this
         *     endpoint.
         *
         *     > This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...) and HTML Forms.
         *
         *     More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         */
        post: operations["completeSelfServiceBrowserSettingsOIDCSettingsFlow"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/errors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get User-Facing Self-Service Errors
         * @description This endpoint returns the error associated with a user-facing self service errors.
         *
         *     This endpoint supports stub values to help you implement the error UI:
         *
         *     `?error=stub:500` - returns a stub 500 (Internal Server Error) error.
         *
         *     More information can be found at [Ory Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).
         */
        get: operations["getSelfServiceError"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/login/api": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Login Flow for API clients
         * @description This endpoint initiates a login flow for API clients such as mobile devices, smart TVs, and so on.
         *
         *     If a valid provided session cookie or session token is provided, a 400 Bad Request error
         *     will be returned unless the URL query parameter `?refresh=true` is set.
         *
         *     To fetch an existing login flow call `/self-service/login/flows?flow=<flow_id>`.
         *
         *     :::warning
         *
         *     You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
         *     Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
         *     you vulnerable to a variety of CSRF attacks, including CSRF login attacks.
         *
         *     This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
         *
         *     :::
         *
         *     More information can be found at [Ory Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).
         */
        get: operations["initializeSelfServiceLoginViaAPIFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/login/browser": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Login Flow for browsers
         * @description This endpoint initializes a browser-based user login flow. Once initialized, the browser will be redirected to
         *     `selfservice.flows.login.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
         *     exists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter
         *     `?refresh=true` was set.
         *
         *     This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
         *
         *     More information can be found at [Ory Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).
         */
        get: operations["initializeSelfServiceLoginViaBrowserFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/login/flows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Login Flow
         * @description This endpoint returns a login flow's context with, for example, error details and other information.
         *
         *     More information can be found at [Ory Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).
         */
        get: operations["getSelfServiceLoginFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/login/methods/password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete Login Flow with Username/Email Password Method
         * @description Use this endpoint to complete a login flow by sending an identity's identifier and password. This endpoint
         *     behaves differently for API and browser flows.
         *
         *     API flows expect `application/json` to be sent in the body and responds with
         *     HTTP 200 and a application/json body with the session token on success;
         *     HTTP 302 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;
         *     HTTP 400 on form validation errors.
         *
         *     Browser flows expect `application/x-www-form-urlencoded` to be sent in the body and responds with
         *     a HTTP 302 redirect to the post/after login URL or the `return_to` value if it was set and if the login succeeded;
         *     a HTTP 302 redirect to the login UI URL with the flow ID containing the validation errors otherwise.
         *
         *     More information can be found at [Ory Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).
         */
        post: operations["completeSelfServiceLoginFlowWithPasswordMethod"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/recovery/api": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Recovery Flow for API Clients
         * @description This endpoint initiates a recovery flow for API clients such as mobile devices, smart TVs, and so on.
         *
         *     If a valid provided session cookie or session token is provided, a 400 Bad Request error.
         *
         *     To fetch an existing recovery flow call `/self-service/recovery/flows?flow=<flow_id>`.
         *
         *     :::warning
         *
         *     You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
         *     Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
         *     you vulnerable to a variety of CSRF attacks.
         *
         *     This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
         *
         *     :::
         *
         *     More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery.mdx).
         */
        get: operations["initializeSelfServiceRecoveryViaAPIFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/recovery/browser": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Recovery Flow for Browser Clients
         * @description This endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to
         *     `selfservice.flows.recovery.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
         *     exists, the browser is returned to the configured return URL.
         *
         *     This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
         *
         *     More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery.mdx).
         */
        get: operations["initializeSelfServiceRecoveryViaBrowserFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/recovery/flows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about a recovery flow
         * @description This endpoint returns a recovery flow's context with, for example, error details and other information.
         *
         *     More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery.mdx).
         */
        get: operations["getSelfServiceRecoveryFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/recovery/methods/link": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete Recovery Flow with Link Method
         * @description Use this endpoint to complete a recovery flow using the link method. This endpoint
         *     behaves differently for API and browser flows and has several states:
         *
         *     `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent
         *     and works with API- and Browser-initiated flows.
         *     For API clients it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid
         *     and a HTTP 302 Found redirect with a fresh recovery flow if the flow was otherwise invalid (e.g. expired).
         *     For Browser clients it returns a HTTP 302 Found redirect to the Recovery UI URL with the Recovery Flow ID appended.
         *     `sent_email` is the success state after `choose_method` and allows the user to request another recovery email. It
         *     works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.
         *     `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow ("sending a recovery link")
         *     does not have any API capabilities. The server responds with a HTTP 302 Found redirect either to the Settings UI URL
         *     (if the link was valid) and instructs the user to update their password, or a redirect to the Recover UI URL with
         *     a new Recovery Flow ID which contains an error message that the recovery link was invalid.
         *
         *     More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery.mdx).
         */
        post: operations["completeSelfServiceRecoveryFlowWithLinkMethod"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/registration/api": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Registration Flow for API clients
         * @description This endpoint initiates a registration flow for API clients such as mobile devices, smart TVs, and so on.
         *
         *     If a valid provided session cookie or session token is provided, a 400 Bad Request error
         *     will be returned unless the URL query parameter `?refresh=true` is set.
         *
         *     To fetch an existing registration flow call `/self-service/registration/flows?flow=<flow_id>`.
         *
         *     :::warning
         *
         *     You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
         *     Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
         *     you vulnerable to a variety of CSRF attacks.
         *
         *     This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
         *
         *     :::
         *
         *     More information can be found at [Ory Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).
         */
        get: operations["initializeSelfServiceRegistrationViaAPIFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/registration/browser": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Registration Flow for browsers
         * @description This endpoint initializes a browser-based user registration flow. Once initialized, the browser will be redirected to
         *     `selfservice.flows.registration.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
         *     exists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter
         *     `?refresh=true` was set.
         *
         *     :::note
         *
         *     This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
         *
         *     :::
         *
         *     More information can be found at [Ory Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).
         */
        get: operations["initializeSelfServiceRegistrationViaBrowserFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/registration/flows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Registration Flow
         * @description This endpoint returns a registration flow's context with, for example, error details and other information.
         *
         *     More information can be found at [Ory Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).
         */
        get: operations["getSelfServiceRegistrationFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/registration/methods/password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete Registration Flow with Username/Email Password Method
         * @description Use this endpoint to complete a registration flow by sending an identity's traits and password. This endpoint
         *     behaves differently for API and browser flows.
         *
         *     API flows expect `application/json` to be sent in the body and respond with
         *     HTTP 200 and a application/json body with the created identity success - if the session hook is configured the
         *     `session` and `session_token` will also be included;
         *     HTTP 302 redirect to a fresh registration flow if the original flow expired with the appropriate error messages set;
         *     HTTP 400 on form validation errors.
         *
         *     Browser flows expect `application/x-www-form-urlencoded` to be sent in the body and responds with
         *     a HTTP 302 redirect to the post/after registration URL or the `return_to` value if it was set and if the registration succeeded;
         *     a HTTP 302 redirect to the registration UI URL with the flow ID containing the validation errors otherwise.
         *
         *     More information can be found at [Ory Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).
         */
        post: operations["completeSelfServiceRegistrationFlowWithPasswordMethod"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/settings/api": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Settings Flow for API Clients
         * @description This endpoint initiates a settings flow for API clients such as mobile devices, smart TVs, and so on.
         *     You must provide a valid Ory Kratos Session Token for this endpoint to respond with HTTP 200 OK.
         *
         *     To fetch an existing settings flow call `/self-service/settings/flows?flow=<flow_id>`.
         *
         *     :::warning
         *
         *     You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
         *     Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
         *     you vulnerable to a variety of CSRF attacks.
         *
         *     This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
         *
         *     :::
         *
         *     More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         */
        get: operations["initializeSelfServiceSettingsViaAPIFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/settings/browser": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Settings Flow for Browsers
         * @description This endpoint initializes a browser-based user settings flow. Once initialized, the browser will be redirected to
         *     `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid
         *     Ory Kratos Session Cookie is included in the request, a login flow will be initialized.
         *
         *     :::note
         *
         *     This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
         *
         *     :::
         *
         *     More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         */
        get: operations["initializeSelfServiceSettingsViaBrowserFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/settings/flows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Settings Flow
         * @description When accessing this endpoint through Ory Kratos' Public API you must ensure that either the Ory Kratos Session Cookie
         *     or the Ory Kratos Session Token are set. The public endpoint does not return 404 status codes
         *     but instead 403 or 500 to improve data privacy.
         *
         *     You can access this endpoint without credentials when using Ory Kratos' Admin API.
         *
         *     More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         */
        get: operations["getSelfServiceSettingsFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/settings/methods/password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete Settings Flow with Username/Email Password Method
         * @description Use this endpoint to complete a settings flow by sending an identity's updated password. This endpoint
         *     behaves differently for API and browser flows.
         *
         *     API-initiated flows expect `application/json` to be sent in the body and respond with
         *     HTTP 200 and an application/json body with the session token on success;
         *     HTTP 302 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set;
         *     HTTP 400 on form validation errors.
         *     HTTP 401 when the endpoint is called without a valid session token.
         *     HTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached.
         *     Implies that the user needs to re-authenticate.
         *
         *     Browser flows expect `application/x-www-form-urlencoded` to be sent in the body and responds with
         *     a HTTP 302 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded;
         *     a HTTP 302 redirect to the Settings UI URL with the flow ID containing the validation errors otherwise.
         *     a HTTP 302 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached.
         *
         *     More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         */
        post: operations["completeSelfServiceSettingsFlowWithPasswordMethod"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/settings/methods/profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete Settings Flow with Profile Method
         * @description Use this endpoint to complete a settings flow by sending an identity's updated traits. This endpoint
         *     behaves differently for API and browser flows.
         *
         *     API-initiated flows expect `application/json` to be sent in the body and respond with
         *     HTTP 200 and an application/json body with the session token on success;
         *     HTTP 302 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set;
         *     HTTP 400 on form validation errors.
         *     HTTP 401 when the endpoint is called without a valid session token.
         *     HTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached and a sensitive field was
         *     updated (e.g. recovery email). Implies that the user needs to re-authenticate.
         *
         *     Browser flows expect `application/x-www-form-urlencoded` to be sent in the body and responds with
         *     a HTTP 302 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded;
         *     a HTTP 302 redirect to the settings UI URL with the flow ID containing the validation errors otherwise.
         *     a HTTP 302 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached.
         *
         *     More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         */
        post: operations["completeSelfServiceSettingsFlowWithProfileMethod"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/verification/api": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Verification Flow for API Clients
         * @description This endpoint initiates a verification flow for API clients such as mobile devices, smart TVs, and so on.
         *
         *     To fetch an existing verification flow call `/self-service/verification/flows?flow=<flow_id>`.
         *
         *     :::warning
         *
         *     You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
         *     Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
         *     you vulnerable to a variety of CSRF attacks.
         *
         *     This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
         *
         *     :::
         *
         *     More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         */
        get: operations["initializeSelfServiceVerificationViaAPIFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/verification/browser": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initialize Verification Flow for Browser Clients
         * @description This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to
         *     `selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.
         *
         *     This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
         *
         *     More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         */
        get: operations["initializeSelfServiceVerificationViaBrowserFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/verification/flows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Verification Flow
         * @description This endpoint returns a verification flow's context with, for example, error details and other information.
         *
         *     More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         */
        get: operations["getSelfServiceVerificationFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/self-service/verification/methods/link": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete Verification Flow with Link Method
         * @description Use this endpoint to complete a verification flow using the link method. This endpoint
         *     behaves differently for API and browser flows and has several states:
         *
         *     `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent
         *     and works with API- and Browser-initiated flows.
         *     For API clients it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid
         *     and a HTTP 302 Found redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired).
         *     For Browser clients it returns a HTTP 302 Found redirect to the Verification UI URL with the Verification Flow ID appended.
         *     `sent_email` is the success state after `choose_method` and allows the user to request another verification email. It
         *     works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.
         *     `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow ("sending a verification link")
         *     does not have any API capabilities. The server responds with a HTTP 302 Found redirect either to the Settings UI URL
         *     (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with
         *     a new Verification Flow ID which contains an error message that the verification link was invalid.
         *
         *     More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         */
        post: operations["completeSelfServiceVerificationFlowWithLinkMethod"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sessions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Revoke and Invalidate a Session
         * @description Use this endpoint to revoke a session using its token. This endpoint is particularly useful for API clients
         *     such as mobile apps to log the user out of the system and invalidate the session.
         *
         *     This endpoint does not remove any HTTP Cookies - use the Self-Service Logout Flow instead.
         */
        delete: operations["revokeSession"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sessions/whoami": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check Who the Current HTTP Session Belongs To
         * @description Uses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated.
         *     Returns a session object in the body or 401 if the credentials are invalid or no credentials were sent.
         *     Additionally when the request it successful it adds the user ID to the 'X-Kratos-Authenticated-Identity-Id' header in the response.
         *
         *     This endpoint is useful for reverse proxies and API Gateways.
         */
        get: operations["whoami"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return Running Software Version.
         * @description This endpoint returns the version of Ory Kratos.
         *
         *     If the service supports TLS Edge Termination, this endpoint does not require the
         *     `X-Forwarded-Proto` header to be set.
         *
         *     Be aware that if you are running multiple nodes of this service, the version will never
         *     refer to the cluster state, only to a single instance.
         */
        get: operations["getVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description nolint:deadcode,unused */
        CompleteSelfServiceBrowserSettingsProfileStrategyFlow: {
            /** @description The Anti-CSRF Token
             *
             *     This token is only required when performing browser flows. */
            csrf_token?: string;
            /** @description Traits contains all of the identity's traits. */
            traits?: Record<string, never>;
        };
        CompleteSelfServiceLoginFlowWithPasswordMethod: {
            /** @description Sending the anti-csrf token is only required for browser login flows. */
            csrf_token?: string;
            /** @description Identifier is the email or username of the user trying to log in. */
            identifier?: string;
            /** @description The user's password. */
            password?: string;
        };
        CompleteSelfServiceSettingsFlowWithPasswordMethod: {
            /** @description CSRFToken is the anti-CSRF token
             *
             *     type: string */
            csrf_token?: string;
            /** @description Password is the updated password
             *
             *     type: string */
            password: string;
        };
        CreateIdentity: {
            /** @description SchemaID is the ID of the JSON Schema to be used for validating the identity's traits. */
            schema_id: string;
            /** @description Traits represent an identity's traits. The identity is able to create, modify, and delete traits
             *     in a self-service manner. The input will always be validated against the JSON Schema defined
             *     in `schema_url`. */
            traits: Record<string, never>;
        };
        CreateRecoveryLink: {
            /** @description Link Expires In
             *
             *     The recovery link will expire at that point in time. Defaults to the configuration value of
             *     `selfservice.flows.recovery.request_lifespan`. */
            expires_in?: string;
            identity_id: components["schemas"]["UUID"];
        };
        /**
         * CredentialsType  represents several different credential types, like password credentials, passwordless credentials,
         * @description and so on.
         */
        CredentialsType: string;
        /** Format: int64 */
        ID: number;
        Identity: {
            id: components["schemas"]["UUID"];
            /** @description RecoveryAddresses contains all the addresses that can be used to recover an identity. */
            recovery_addresses?: components["schemas"]["RecoveryAddress"][];
            /** @description SchemaID is the ID of the JSON Schema to be used for validating the identity's traits. */
            schema_id: string;
            /** @description SchemaURL is the URL of the endpoint where the identity's traits schema can be fetched from.
             *
             *     format: url */
            schema_url: string;
            traits: components["schemas"]["Traits"];
            /** @description VerifiableAddresses contains all the addresses that can be verified by the user. */
            verifiable_addresses?: components["schemas"]["VerifiableAddress"][];
        };
        /**
         * NullTime implements sql.NullTime functionality.
         * Format: date-time
         */
        NullTime: string;
        RecoveryAddress: {
            id: components["schemas"]["UUID"];
            value: string;
            via: components["schemas"]["RecoveryAddressType"];
        };
        RecoveryAddressType: string;
        State: string;
        Traits: Record<string, never>;
        /**
         * Type is the flow type.
         * @description The flow type can either be `api` or `browser`.
         */
        Type: string;
        /** Format: uuid4 */
        UUID: string;
        UpdateIdentity: {
            /** @description SchemaID is the ID of the JSON Schema to be used for validating the identity's traits. If set
             *     will update the Identity's SchemaID. */
            schema_id?: string;
            /** @description Traits represent an identity's traits. The identity is able to create, modify, and delete traits
             *     in a self-service manner. The input will always be validated against the JSON Schema defined
             *     in `schema_id`. */
            traits: Record<string, never>;
        };
        VerifiableAddress: {
            id: components["schemas"]["UUID"];
            status: components["schemas"]["VerifiableAddressStatus"];
            value: string;
            verified: boolean;
            verified_at?: components["schemas"]["NullTime"];
            via: components["schemas"]["VerifiableAddressType"];
        };
        VerifiableAddressStatus: string;
        VerifiableAddressType: string;
        completeSelfServiceBrowserSettingsOIDCFlowPayload: {
            /** @description Flow ID is the flow's ID.
             *
             *     in: query */
            flow?: string;
            /** @description Link this provider
             *
             *     Either this or `unlink` must be set.
             *
             *     type: string
             *     in: body */
            link?: string;
            /** @description Unlink this provider
             *
             *     Either this or `link` must be set.
             *
             *     type: string
             *     in: body */
            unlink?: string;
        };
        completeSelfServiceRecoveryFlowWithLinkMethod: {
            /** @description Sending the anti-csrf token is only required for browser login flows. */
            csrf_token?: string;
            /** @description Email to Recover
             *
             *     Needs to be set when initiating the flow. If the email is a registered
             *     recovery email, a recovery link will be sent. If the email is not known,
             *     a email with details on what happened will be sent instead.
             *
             *     format: email
             *     in: body */
            email?: string;
        };
        completeSelfServiceVerificationFlowWithLinkMethod: {
            /** @description Sending the anti-csrf token is only required for browser login flows. */
            csrf_token?: string;
            /** @description Email to Verify
             *
             *     Needs to be set when initiating the flow. If the email is a registered
             *     verification email, a verification link will be sent. If the email is not known,
             *     a email with details on what happened will be sent instead.
             *
             *     format: email
             *     in: body */
            email?: string;
        };
        errorContainer: {
            /** @description Errors in the container */
            errors: Record<string, never>;
            id: components["schemas"]["UUID"];
        };
        /** @description HTMLForm represents a HTML Form. The container can work with both HTTP Form and JSON requests */
        form: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
        };
        /**
         * Error response
         * @description Error responses are sent when an error (e.g. unauthorized, bad request, ...) occurred.
         */
        genericError: {
            error?: components["schemas"]["genericErrorPayload"];
        };
        genericErrorPayload: {
            /**
             * Format: int64
             * @description Code represents the error status code (404, 403, 401, ...).
             * @example 404
             */
            code?: number;
            /**
             * @description Debug contains debug information. This is usually not available and has to be enabled.
             * @example The database adapter was unable to find the element
             */
            debug?: string;
            details?: {
                [key: string]: unknown;
            };
            message?: string;
            reason?: string;
            request?: string;
            status?: string;
        };
        healthNotReadyStatus: {
            /** @description Errors contains a list of errors that caused the not ready status. */
            errors?: {
                [key: string]: string;
            };
        };
        healthStatus: {
            /** @description Status always contains "ok". */
            status?: string;
        };
        /**
         * Login Flow
         * @description This object represents a login flow. A login flow is initiated at the "Initiate Login API / Browser Flow"
         *     endpoint by a client.
         *
         *     Once a login flow is completed successfully, a session cookie or session token will be issued.
         */
        loginFlow: {
            active?: components["schemas"]["CredentialsType"];
            /**
             * Format: date-time
             * @description ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,
             *     a new flow has to be initiated.
             */
            expires_at: string;
            /** @description Forced stores whether this login flow should enforce re-authentication. */
            forced?: boolean;
            id: components["schemas"]["UUID"];
            /**
             * Format: date-time
             * @description IssuedAt is the time (UTC) when the flow started.
             */
            issued_at: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description List of login methods
             *
             *     This is the list of available login methods with their required form fields, such as `identifier` and `password`
             *     for the password login method. This will also contain error messages such as "password can not be empty". */
            methods: {
                [key: string]: components["schemas"]["loginFlowMethod"];
            };
            /** @description RequestURL is the initial URL that was requested from Ory Kratos. It can be used
             *     to forward information contained in the URL's path or query for example. */
            request_url: string;
            type?: components["schemas"]["Type"];
        };
        loginFlowMethod: {
            config: components["schemas"]["loginFlowMethodConfig"];
            method: components["schemas"]["CredentialsType"];
        };
        loginFlowMethodConfig: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
            providers?: components["schemas"]["uiNodes"];
        };
        loginFlowMethodConfigPayload: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
            providers?: components["schemas"]["uiNodes"];
        };
        /** @description The Response for Login Flows via API */
        loginViaApiResponse: {
            session: components["schemas"]["session"];
            /** @description The Session Token
             *
             *     A session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization
             *     Header:
             *
             *     Authorization: bearer ${session-token}
             *
             *     The session token is only issued for API flows, not for Browser flows! */
            session_token: string;
        };
        /**
         * A Recovery Flow
         * @description This request is used when an identity wants to recover their account.
         *
         *     We recommend reading the [Account Recovery Documentation](../self-service/flows/password-reset-account-recovery)
         */
        recoveryFlow: {
            /** @description Active, if set, contains the registration method that is being used. It is initially
             *     not set. */
            active?: string;
            /**
             * Format: date-time
             * @description ExpiresAt is the time (UTC) when the request expires. If the user still wishes to update the setting,
             *     a new request has to be initiated.
             */
            expires_at: string;
            id: components["schemas"]["UUID"];
            /**
             * Format: date-time
             * @description IssuedAt is the time (UTC) when the request occurred.
             */
            issued_at: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Methods contains context for all account recovery methods. If a registration request has been
             *     processed, but for example the password is incorrect, this will contain error messages. */
            methods: {
                [key: string]: components["schemas"]["recoveryFlowMethod"];
            };
            /** @description RequestURL is the initial URL that was requested from Ory Kratos. It can be used
             *     to forward information contained in the URL's path or query for example. */
            request_url: string;
            state: components["schemas"]["State"];
            type?: components["schemas"]["Type"];
        };
        recoveryFlowMethod: {
            config: components["schemas"]["recoveryFlowMethodConfig"];
            /** @description Method contains the request credentials type. */
            method: string;
        };
        recoveryFlowMethodConfig: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
        };
        recoveryFlowMethodConfigPayload: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
        };
        recoveryLink: {
            /**
             * Format: date-time
             * @description Recovery Link Expires At
             *
             *     The timestamp when the recovery link expires.
             */
            expires_at?: string;
            /** @description Recovery Link
             *
             *     This link can be used to recover the account. */
            recovery_link: string;
        };
        registrationFlow: {
            active?: components["schemas"]["CredentialsType"];
            /**
             * Format: date-time
             * @description ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,
             *     a new flow has to be initiated.
             */
            expires_at: string;
            id: components["schemas"]["UUID"];
            /**
             * Format: date-time
             * @description IssuedAt is the time (UTC) when the flow occurred.
             */
            issued_at: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Methods contains context for all enabled registration methods. If a registration flow has been
             *     processed, but for example the password is incorrect, this will contain error messages. */
            methods: {
                [key: string]: components["schemas"]["registrationFlowMethod"];
            };
            /** @description RequestURL is the initial URL that was requested from Ory Kratos. It can be used
             *     to forward information contained in the URL's path or query for example. */
            request_url: string;
            type?: components["schemas"]["Type"];
        };
        registrationFlowMethod: {
            config: components["schemas"]["registrationFlowMethodConfig"];
            method: components["schemas"]["CredentialsType"];
        };
        registrationFlowMethodConfig: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
            /** @description Providers is set for the "oidc" registration method. */
            providers?: components["schemas"]["uiNodes"][];
        };
        registrationFlowMethodConfigPayload: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
            /** @description Providers is set for the "oidc" registration method. */
            providers?: components["schemas"]["uiNodes"][];
        };
        /** @description The Response for Registration Flows via API */
        registrationViaApiResponse: {
            identity: components["schemas"]["Identity"];
            session?: components["schemas"]["session"];
            /** @description The Session Token
             *
             *     This field is only set when the session hook is configured as a post-registration hook.
             *
             *     A session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization
             *     Header:
             *
             *     Authorization: bearer ${session-token}
             *
             *     The session token is only issued for API flows, not for Browser flows! */
            session_token: string;
        };
        revokeSession: {
            /** @description The Session Token
             *
             *     Invalidate this session token. */
            session_token: string;
        };
        session: {
            active?: boolean;
            /** Format: date-time */
            authenticated_at: string;
            /** Format: date-time */
            expires_at: string;
            id: components["schemas"]["UUID"];
            identity: components["schemas"]["Identity"];
            /** Format: date-time */
            issued_at: string;
        };
        /**
         * Flow represents a Settings Flow
         * @description This flow is used when an identity wants to update settings
         *     (e.g. profile data, passwords, ...) in a selfservice manner.
         *
         *     We recommend reading the [User Settings Documentation](../self-service/flows/user-settings)
         */
        settingsFlow: {
            /** @description Active, if set, contains the registration method that is being used. It is initially
             *     not set. */
            active?: string;
            /**
             * Format: date-time
             * @description ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to update the setting,
             *     a new flow has to be initiated.
             */
            expires_at: string;
            id: components["schemas"]["UUID"];
            identity: components["schemas"]["Identity"];
            /**
             * Format: date-time
             * @description IssuedAt is the time (UTC) when the flow occurred.
             */
            issued_at: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Methods contains context for all enabled registration methods. If a settings flow has been
             *     processed, but for example the first name is empty, this will contain error messages. */
            methods: {
                [key: string]: components["schemas"]["settingsFlowMethod"];
            };
            /** @description RequestURL is the initial URL that was requested from Ory Kratos. It can be used
             *     to forward information contained in the URL's path or query for example. */
            request_url: string;
            state: components["schemas"]["State"];
            type?: components["schemas"]["Type"];
        };
        settingsFlowMethod: {
            config: components["schemas"]["settingsFlowMethodConfig"];
            /** @description Method is the name of this flow method. */
            method: string;
        };
        settingsFlowMethodConfig: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
        };
        settingsFlowMethodConfigPayload: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
        };
        settingsProfileFormConfig: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
        };
        /** @description The Response for Settings Flows via API */
        settingsViaApiResponse: {
            flow: components["schemas"]["settingsFlow"];
            identity: components["schemas"]["Identity"];
        };
        /**
         * Node represents a flow's nodes
         * @description Nodes are represented as HTML elements or their native UI equivalents. For example,
         *     a node can be an `<img>` tag, or an `<input element>` but also `some plain text`.
         */
        uiNode: {
            attributes: components["schemas"]["uiNodeAttributes"];
            group?: components["schemas"]["uiNodeGroup"];
            messages?: components["schemas"]["uiTexts"];
            type: components["schemas"]["uiNodeType"];
        };
        /** AnchorAttributes represents the attributes of an anchor node. */
        uiNodeAnchorAttributes: {
            /** @description The link's href (destination) URL.
             *
             *     format: uri */
            href: string;
            title: components["schemas"]["uiText"];
        };
        /** Attributes represents a list of attributes (e.g. `href="foo"` for links). */
        uiNodeAttributes: components["schemas"]["uiNodeInputAttributes"] | components["schemas"]["uiNodeTextAttributes"] | components["schemas"]["uiNodeImageAttributes"] | components["schemas"]["uiNodeAnchorAttributes"];
        uiNodeGroup: string;
        /** ImageAttributes represents the attributes of an image node. */
        uiNodeImageAttributes: {
            /** @description The image's source URL.
             *
             *     format: uri */
            src: string;
        };
        uiNodeInputAttributeType: string;
        /** @description InputAttributes represents the attributes of an input node */
        uiNodeInputAttributes: {
            /** @description Sets the input's disabled field to true or false. */
            disabled: boolean;
            label?: components["schemas"]["uiText"];
            /** @description The input's element name. */
            name: string;
            /** @description The input's pattern. */
            pattern?: string;
            /** @description Mark this input field as required. */
            required?: boolean;
            type: components["schemas"]["uiNodeInputAttributeType"];
            /** @description The input's value. */
            value?: (string | number | boolean) | null;
        };
        /** TextAttributes represents the attributes of a text node. */
        uiNodeTextAttributes: {
            text: components["schemas"]["uiText"];
        };
        uiNodeType: string;
        uiNodes: components["schemas"]["uiNode"][];
        uiText: {
            /** @description The message's context. Useful when customizing messages. */
            context?: Record<string, never>;
            id: components["schemas"]["ID"];
            /** @description The message text. Written in american english. */
            text: string;
            type: components["schemas"]["uiTextType"];
        };
        uiTextType: string;
        uiTexts: components["schemas"]["uiText"][];
        /**
         * A Verification Flow
         * @description Used to verify an out-of-band communication
         *     channel such as an email address or a phone number.
         *
         *     For more information head over to: https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation
         */
        verificationFlow: {
            /** @description Active, if set, contains the registration method that is being used. It is initially
             *     not set. */
            active?: string;
            /**
             * Format: date-time
             * @description ExpiresAt is the time (UTC) when the request expires. If the user still wishes to verify the address,
             *     a new request has to be initiated.
             */
            expires_at?: string;
            id?: components["schemas"]["UUID"];
            /**
             * Format: date-time
             * @description IssuedAt is the time (UTC) when the request occurred.
             */
            issued_at?: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Methods contains context for all account verification methods. If a registration request has been
             *     processed, but for example the password is incorrect, this will contain error messages. */
            methods: {
                [key: string]: components["schemas"]["verificationFlowMethod"];
            };
            /** @description RequestURL is the initial URL that was requested from Ory Kratos. It can be used
             *     to forward information contained in the URL's path or query for example. */
            request_url?: string;
            state: components["schemas"]["State"];
            type?: components["schemas"]["Type"];
        };
        verificationFlowMethod: {
            config: components["schemas"]["verificationFlowMethodConfig"];
            /** @description Method contains the request credentials type. */
            method: string;
        };
        verificationFlowMethodConfig: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
        };
        verificationFlowMethodConfigPayload: {
            /** @description Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`. */
            action: string;
            messages?: components["schemas"]["uiTexts"];
            /** @description Method is the form method (e.g. POST) */
            method: string;
            nodes: components["schemas"]["uiNodes"];
        };
        version: {
            /** @description Version is the service's version. */
            version?: string;
        };
    };
    responses: {
        /** @description Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
         *     typically 201. */
        emptyResponse: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description User-facing error response */
        errorContainer: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["errorContainer"];
            };
        };
        /** @description A list of identities. */
        identityList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Identity"][];
            };
        };
        /** @description A single identity. */
        identityResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Identity"];
            };
        };
        /** @description The raw identity traits schema */
        schemaResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": Record<string, never>;
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    isAlive: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ory Kratos is ready to accept connections. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["healthStatus"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    isReady: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ory Kratos is ready to accept requests. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Always "ok". */
                        status?: string;
                    };
                };
            };
            /** @description Ory Kratos is not yet ready to accept requests. */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Errors contains a list of errors that caused the not ready status. */
                        errors?: {
                            [key: string]: string;
                        };
                    };
                };
            };
        };
    };
    listIdentities: {
        parameters: {
            query?: {
                /** @description Items per Page
                 *
                 *     This is the number of items per page. */
                per_page?: number;
                /** @description Pagination Page */
                page?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["identityList"];
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    createIdentity: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateIdentity"];
            };
        };
        responses: {
            201: components["responses"]["identityResponse"];
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getIdentity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID must be set to the ID of identity you want to get */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["identityResponse"];
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    updateIdentity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID must be set to the ID of identity you want to update */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateIdentity"];
            };
        };
        responses: {
            200: components["responses"]["identityResponse"];
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    deleteIdentity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID is the identity's ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["emptyResponse"];
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    prometheus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["emptyResponse"];
        };
    };
    createRecoveryLink: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateRecoveryLink"];
            };
        };
        responses: {
            /** @description recoveryLink */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["recoveryLink"];
                };
            };
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getSchema: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID must be set to the ID of schema you want to get */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["schemaResponse"];
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceBrowserLogoutFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    completeSelfServiceBrowserSettingsOIDCSettingsFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getSelfServiceError: {
        parameters: {
            query: {
                /** @description Error is the container's ID */
                error: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["errorContainer"];
            /** @description genericError */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceLoginViaAPIFlow: {
        parameters: {
            query?: {
                /** @description Refresh a login session
                 *
                 *     If set to true, this will refresh an existing login session by
                 *     asking the user to sign in again. This will reset the
                 *     authenticated_at time of the session. */
                refresh?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description loginFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["loginFlow"];
                };
            };
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceLoginViaBrowserFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getSelfServiceLoginFlow: {
        parameters: {
            query: {
                /** @description The Login Flow ID
                 *
                 *     The value for this parameter comes from `flow` URL Query parameter sent to your
                 *     application (e.g. `/login?flow=abcde`). */
                id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description loginFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["loginFlow"];
                };
            };
            /** @description genericError */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            410: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    completeSelfServiceLoginFlowWithPasswordMethod: {
        parameters: {
            query: {
                /** @description The Flow ID */
                flow: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CompleteSelfServiceLoginFlowWithPasswordMethod"];
                "application/x-www-form-urlencoded": components["schemas"]["CompleteSelfServiceLoginFlowWithPasswordMethod"];
            };
        };
        responses: {
            /** @description loginViaApiResponse */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["loginViaApiResponse"];
                };
            };
            302: components["responses"]["emptyResponse"];
            /** @description loginFlow */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["loginFlow"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceRecoveryViaAPIFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description recoveryFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["recoveryFlow"];
                };
            };
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceRecoveryViaBrowserFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getSelfServiceRecoveryFlow: {
        parameters: {
            query: {
                /** @description The Flow ID
                 *
                 *     The value for this parameter comes from `request` URL Query parameter sent to your
                 *     application (e.g. `/recovery?flow=abcde`). */
                id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description recoveryFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["recoveryFlow"];
                };
            };
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            410: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    completeSelfServiceRecoveryFlowWithLinkMethod: {
        parameters: {
            query?: {
                /** @description Recovery Token
                 *
                 *     The recovery token which completes the recovery request. If the token
                 *     is invalid (e.g. expired) an error will be shown to the end-user. */
                token?: string;
                /** @description The Flow ID
                 *
                 *     format: uuid */
                flow?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["completeSelfServiceRecoveryFlowWithLinkMethod"];
                "application/x-www-form-urlencoded": components["schemas"]["completeSelfServiceRecoveryFlowWithLinkMethod"];
            };
        };
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description recoveryFlow */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["recoveryFlow"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceRegistrationViaAPIFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description registrationFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["registrationFlow"];
                };
            };
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceRegistrationViaBrowserFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getSelfServiceRegistrationFlow: {
        parameters: {
            query: {
                /** @description The Registration Flow ID
                 *
                 *     The value for this parameter comes from `flow` URL Query parameter sent to your
                 *     application (e.g. `/registration?flow=abcde`). */
                id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description registrationFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["registrationFlow"];
                };
            };
            /** @description genericError */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            410: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    completeSelfServiceRegistrationFlowWithPasswordMethod: {
        parameters: {
            query?: {
                /** @description Flow is flow ID. */
                flow?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": Record<string, never>;
                "application/x-www-form-urlencoded": Record<string, never>;
            };
        };
        responses: {
            /** @description registrationViaApiResponse */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["registrationViaApiResponse"];
                };
            };
            302: components["responses"]["emptyResponse"];
            /** @description registrationFlow */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["registrationFlow"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceSettingsViaAPIFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description settingsFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["settingsFlow"];
                };
            };
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceSettingsViaBrowserFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getSelfServiceSettingsFlow: {
        parameters: {
            query: {
                /** @description ID is the Settings Flow ID
                 *
                 *     The value for this parameter comes from `flow` URL Query parameter sent to your
                 *     application (e.g. `/settings?flow=abcde`). */
                id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description settingsFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["settingsFlow"];
                };
            };
            /** @description genericError */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            410: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    completeSelfServiceSettingsFlowWithPasswordMethod: {
        parameters: {
            query?: {
                /** @description Flow is flow ID. */
                flow?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CompleteSelfServiceSettingsFlowWithPasswordMethod"];
                "application/x-www-form-urlencoded": components["schemas"]["CompleteSelfServiceSettingsFlowWithPasswordMethod"];
            };
        };
        responses: {
            /** @description settingsViaApiResponse */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["settingsViaApiResponse"];
                };
            };
            302: components["responses"]["emptyResponse"];
            /** @description settingsFlow */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["settingsFlow"];
                };
            };
            /** @description genericError */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    completeSelfServiceSettingsFlowWithProfileMethod: {
        parameters: {
            query?: {
                /** @description Flow is flow ID. */
                flow?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": Record<string, never>;
                "application/x-www-form-urlencoded": Record<string, never>;
            };
        };
        responses: {
            /** @description settingsFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["settingsFlow"];
                };
            };
            302: components["responses"]["emptyResponse"];
            /** @description settingsFlow */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["settingsFlow"];
                };
            };
            /** @description genericError */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceVerificationViaAPIFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description verificationFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["verificationFlow"];
                };
            };
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    initializeSelfServiceVerificationViaBrowserFlow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getSelfServiceVerificationFlow: {
        parameters: {
            query: {
                /** @description The Flow ID
                 *
                 *     The value for this parameter comes from `request` URL Query parameter sent to your
                 *     application (e.g. `/verification?flow=abcde`). */
                id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description verificationFlow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["verificationFlow"];
                };
            };
            /** @description genericError */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    completeSelfServiceVerificationFlowWithLinkMethod: {
        parameters: {
            query?: {
                /** @description Verification Token
                 *
                 *     The verification token which completes the verification request. If the token
                 *     is invalid (e.g. expired) an error will be shown to the end-user. */
                token?: string;
                /** @description The Flow ID
                 *
                 *     format: uuid */
                flow?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["completeSelfServiceVerificationFlowWithLinkMethod"];
                "application/x-www-form-urlencoded": components["schemas"]["completeSelfServiceVerificationFlowWithLinkMethod"];
            };
        };
        responses: {
            302: components["responses"]["emptyResponse"];
            /** @description verificationFlow */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["verificationFlow"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    revokeSession: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["revokeSession"];
            };
        };
        responses: {
            204: components["responses"]["emptyResponse"];
            /** @description genericError */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    whoami: {
        parameters: {
            query?: {
                /** @description in: authorization */
                Authorization?: string;
            };
            header?: {
                Cookie?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description session */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["session"];
                };
            };
            /** @description genericError */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
            /** @description genericError */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["genericError"];
                };
            };
        };
    };
    getVersion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returns the Ory Kratos version. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The version of Ory Kratos. */
                        version?: string;
                    };
                };
            };
        };
    };
}
